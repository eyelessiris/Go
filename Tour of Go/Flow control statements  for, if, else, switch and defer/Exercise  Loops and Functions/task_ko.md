# 연습: 루프와 함수

함수와 루프를 연습하기 위해, 제곱근 함수를 구현해 봅시다. 숫자 `x`가 주어졌을 때, `z²`가 `x`와 가장 가까운 숫자 `z`를 찾는 것이 목표입니다.

컴퓨터는 일반적으로 루프를 사용하여 `x`의 제곱근을 계산합니다.  
어떤 초기 추측값 `z`로 시작하여, `z²`와 `x`의 차이에 따라 `z`를 조정하면, 더 나은 추측값을 얻을 수 있습니다:

	z -= (z*z - x) / (2*z)

이 조정을 반복하면 추측값이 점점 더 정확해져 실제 제곱근에 가까운 답에 도달할 수 있습니다.

주어진 `func Sqrt`에서 이 동작을 구현해 보세요.  
`z`의 초기 추측값은 입력값과 상관없이 1부터 시작하는 것이 적당합니다.  
처음에는 계산을 10번 반복하며, 각 단계의 `z` 값을 출력해 보세요.  
이를 통해 다양한 `x` 값(1, 2, 3, ...)에 대해 얼마나 정확히 답을 얻을 수 있는지, 그리고 추측값이 얼마나 빠르게 개선되는지 확인해 보세요.

힌트: 실수 값을 선언하고 초기화하려면, 소수점 표기법을 사용하거나 형 변환을 적용하세요:

	z := 1.0  
	z := float64(1)

다음으로, 루프 조건을 변경하여 값이 더 이상 변하지 않거나(혹은 아주 적게 변할 때) 루프를 종료하도록 하세요.  
10번 반복하는 것보다 더 적거나 많은 반복을 해야 할 수도 있습니다.  
또한, `z`의 초기 추측값으로 `x`나 `x/2` 같은 다른 값을 시도해 보세요.  
표준 라이브러리의 [math.Sqrt](https://go.dev/pkg/math/#Sqrt) 함수와 비교했을 때, 함수의 결과가 얼마나 가까운지 확인해 보세요.

(*참고:* 알고리즘의 세부 사항에 관심이 있다면, 위의 `z² − x`는 `z²`가 목표 위치(`x`)에서 얼마나 먼지를 나타냅니다.  
그리고 `2z`로 나누는 것은 `z²`의 도함수로, `z²`가 얼마나 빠르게 변하는지에 따라 `z` 조정량을 스케일 조정하는 역할을 합니다.  
이 일반적인 방법은 [뉴턴의 방법](https://en.wikipedia.org/wiki/Newton%27s_method)이라고 불리며, 여러 함수에서 잘 동작하지만 특히 제곱근 계산에 매우 적합합니다.)

<div class="hint" title="클릭하여 가능한 해결책 보기">

    package main
    
    import (
    	"fmt"
    	"math"
    )
    
    const delta = 1e-6
    
    func Sqrt(x float64) float64 {
    	z := x
    	n := 0.0
    	for math.Abs(n-z) > delta {
    		n, z = z, z-(z*z-x)/(2*z)
    	}
    	return z
    }
    
    func main() {
    	const x = 2
    	mine, theirs := Sqrt(x), math.Sqrt(x)
    	fmt.Println(mine, theirs, mine-theirs)
    }
    
</div>